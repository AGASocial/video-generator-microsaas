# To-Do List

## Video Storage & Download Implementation

### Current Status
- ‚úÖ **Implementation Complete!**
- ‚úÖ Storage bucket SQL script created (`scripts/006_create_videos_bucket.sql`)
- ‚úÖ Video storage utility created (`lib/video-storage.ts`)
- ‚úÖ Webhook endpoint updated to download and store videos
- ‚úÖ Background polling updated to download and store videos
- ‚úÖ Videos are now stored in Supabase Storage bucket `videos`
- ‚úÖ Frontend automatically works (reads `video_url` from database)
- ‚ö†Ô∏è **ACTION REQUIRED**: Run SQL script to create storage bucket - Done

### Problem
When a video is complete:
1. OpenAI/webhook provides a `videoUrl` (external URL)
2. We store only the URL in database
3. Video stays on OpenAI's servers
4. **If OpenAI deletes the video, it's lost forever**

### Solution: Download & Store Videos

**Option 1: Supabase Storage (Recommended)**
- Download video from external URL
- Upload to Supabase Storage bucket
- Store Supabase URL in database
- Videos are permanently stored and accessible


### Implementation Steps

‚úÖ **COMPLETED:**

1. ‚úÖ **Created Supabase Storage Bucket SQL Script** (`scripts/006_create_videos_bucket.sql`)
   - Creates `videos` bucket
   - Sets up RLS policies for upload, read, and delete
   - **ACTION REQUIRED**: Run this script in your Supabase SQL editor

2. ‚úÖ **Created Video Storage Utility** (`lib/video-storage.ts`)
   - `downloadAndStoreVideo()` - Downloads from any external URL and stores in Supabase
   - `downloadAndStoreVideoFromOpenAI()` - Specifically for OpenAI Sora videos
   - Handles errors gracefully with fallback

3. ‚úÖ **Updated Webhook Endpoint** (`app/api/webhook/video-complete/route.ts`)
   - Downloads video when webhook receives completion
   - Uploads to Supabase Storage
   - Updates database with Supabase public URL
   - Falls back gracefully if storage fails

4. ‚úÖ **Updated Background Polling** (`app/api/generate/route.ts`)
   - Downloads and stores video when polling detects completion
   - Handles immediate completion (when video is ready instantly)
   - Falls back to proxy URL if storage fails

5. ‚úÖ **Frontend** - No changes needed!
   - Profile page already reads `video_url` from database
   - Videos will automatically display from Supabase Storage URLs
   - Download functionality works with Supabase URLs

### Storage Location Options

**Supabase Storage:**
- ‚úÖ Easy integration (already using Supabase)
- ‚úÖ Built-in CDN
- ‚úÖ Automatic backups
- ‚ö†Ô∏è Storage limits on free tier
- ‚úÖ Good for MVP/small scale

**AWS S3:**
- ‚úÖ Highly scalable
- ‚úÖ Cost-effective for large volumes
- ‚úÖ Better for production at scale
- ‚ö†Ô∏è Requires AWS setup

**Current: External URLs Only**
- ‚ùå No permanent storage
- ‚ùå Risk of video loss
- ‚ùå Dependent on external service

### File Naming Convention

```
videos/
  {user_id}/
    {video_id}.mp4
```

Example: `videos/abc123/video-uuid-456.mp4`

### Benefits of Storing Videos

- ‚úÖ Permanent storage (videos won't be lost)
- ‚úÖ Independent of external service
- ‚úÖ Better performance (CDN delivery)
- ‚úÖ User ownership (videos belong to your platform)
- ‚úÖ Compliance (data retention policies)

### Considerations

1. **Storage Costs**
   - Videos are large files (8 seconds = ~5-10MB)
   - Calculate storage needs: users √ó videos √ó size
   - Consider cleanup policies for old videos

2. **Download Time**
   - Large files take time to download
   - Consider async processing (queue system)
   - Show "Processing video storage..." status

3. **Error Handling**
   - What if download fails?
   - What if upload fails?
   - Keep original URL as fallback
   - Retry mechanism

4. **Storage Limits**
   - Supabase free tier: 1GB
   - Monitor storage usage
   - Implement cleanup for old videos

### Priority
‚úÖ **IMPLEMENTED** - Videos are now stored permanently in Supabase Storage

### Next Steps

1. **Run SQL Script** (Required):
   ```bash
   # Run in Supabase SQL Editor:
   scripts/006_create_videos_bucket.sql
   ```

2. **Test the Implementation**:
   - Generate a new video
   - Check that it's stored in Supabase Storage bucket `videos`
   - Verify the `video_url` in database points to Supabase Storage
   - Confirm video displays correctly in profile page

3. **Monitor Storage Usage**:
   - Check Supabase dashboard for storage usage
   - Videos are stored at: `videos/{user_id}/{video_id}.mp4`
   - Each video is ~5-10MB (8 seconds)

### How It Works

1. **Video Generation**:
   - User generates video ‚Üí stored in `video_history` with `status: "processing"`
   - OpenAI processes video

2. **Video Completion** (via webhook or polling):
   - System detects video is complete
   - Calls `downloadAndStoreVideoFromOpenAI()`
   - Downloads video from OpenAI
   - Uploads to Supabase Storage: `videos/{user_id}/{video_id}.mp4`
   - Updates database: `video_url = "https://[project].supabase.co/storage/v1/object/public/videos/..."`

3. **Frontend Display**:
   - Profile page queries `video_history` table
   - Displays videos using `video_url` (now Supabase URLs)
   - Videos are served from Supabase CDN

---

## Video Generation Webhook Implementation

### Current Status
- ‚úÖ Webhook endpoint exists at `/api/webhook/video-complete`
- ‚úÖ Endpoint accepts: `videoId`, `videoUrl`, `status`
- ‚ö†Ô∏è Currently using polling system (background + frontend)
- üîÑ Need to switch to webhook-based approach

### Webhook Endpoint Details

**URL:** `POST /api/webhook/video-complete`

**Request Body:**
```json
{
  "videoId": "uuid-of-video-entry",
  "videoUrl": "https://...",
  "status": "completed" // or "failed"
}
```

**Response:**
```json
{
  "success": true
}
```

### Implementation Steps

1. **Configure OpenAI/Video Service to Call Webhook**
   - Set webhook URL: `https://yourdomain.com/api/webhook/video-complete`
   - Ensure service passes `videoId` (from initial request)
   - Ensure service passes `videoUrl` when video is ready
   - Ensure service passes `status` ("completed" or "failed")

2. **Update Video Generation API** (`app/api/generate/route.ts`)
   - Remove or disable background polling function
   - When creating video entry, ensure `videoId` is passed to OpenAI service
   - OpenAI service should include `videoId` in webhook callback
   - Keep frontend polling as fallback (or remove if webhook is reliable)

3. **Add Webhook Security** (Optional but Recommended)
   - Add webhook signature verification
   - Add API key or secret token validation
   - Add rate limiting to prevent abuse

4. **Update Frontend** (`components/video-generator-form.tsx`)
   - Keep polling as fallback mechanism
   - Or remove polling if webhook is 100% reliable
   - Show "Waiting for video..." message while processing

### Benefits of Webhook Approach

- ‚úÖ More efficient (no constant polling)
- ‚úÖ Faster updates (immediate notification when ready)
- ‚úÖ Less server load (no background polling)
- ‚úÖ Better scalability
- ‚úÖ Real-time updates

### Current Polling System (To Be Replaced)

**Background Polling:**
- Polls OpenAI API every 5 seconds
- Runs server-side in background
- Updates database when video is ready

**Frontend Polling:**
- Polls `/api/video/status` every 3 seconds
- Shows updates to user in real-time
- Can be kept as fallback

### Webhook Security Considerations

1. **Add Webhook Secret/Token**
   ```typescript
   // In webhook endpoint
   const webhookSecret = request.headers.get("x-webhook-secret");
   if (webhookSecret !== process.env.VIDEO_WEBHOOK_SECRET) {
     return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
   }
   ```

2. **Add Request Validation**
   - Validate `videoId` exists in database
   - Validate `videoUrl` is a valid URL
   - Validate `status` is valid ("completed" or "failed")

3. **Add Rate Limiting**
   - Prevent webhook spam
   - Use middleware or API gateway

### Testing Checklist

- [ ] Configure OpenAI service with webhook URL
- [ ] Test webhook receives callbacks
- [ ] Verify video status updates in database
- [ ] Verify frontend shows updated video
- [ ] Test error handling (failed videos)
- [ ] Test webhook security (unauthorized requests)
- [ ] Remove/disable polling system
- [ ] Monitor webhook reliability

### Notes

- The webhook endpoint already exists and is functional
- Current polling system works but is less efficient
- Webhook approach is preferred for production
- Keep polling as fallback during transition period

